# Open-Sora 1.3 报告

- [视频压缩网络](#视频压缩网络)
- [升级版带位移窗口注意力的STDiT](#升级版带位移窗口注意力的STDiT)
- [简单有效的模型条件控制](#简单有效的模型条件控制)
- [评估方法](#评估方法)

在Open-Sora 1.3版本中，我们在超过60M（约85k小时）的数据上训练了一个1.1B参数的模型，训练耗时35k H100 GPU小时，支持0~113帧、360p和720p分辨率以及多种宽高比的视频生成。我们的配置如下。延续1.2版本的特性，Open-Sora 1.3同样支持图像到视频的生成和视频延展。

|      | image | 49 frames  | 65 frames  | 81 frames  | 97 frames | 113 frames |
| ---- | ----- | ---------- | ---------- | ---------- | --------- | ---------- |
| 360p | ✅     | ✅         | ✅         | ✅         | ✅         |✅          |
| 720p | ✅     | ✅         | ✅         | ✅         | ✅         |✅          |

这里✅表示在训练过程中已经见过的数据。

除了Open-Sora 1.2中引入的特性外，Open-Sora 1.3的亮点包括：

- 视频压缩网络
- 升级版带位移窗口注意力的STDiT
- 更多数据和更好的多阶段训练
- 简单有效的模型条件控制
- 更好的评估指标

以上所有改进的实现（包括训练和推理）都在Open-Sora 1.3版本中提供。以下部分将详细介绍这些改进。我们还优化了代码库和文档以使其更易于使用和开发，并添加了LLM优化器来[优化输入提示词](/README.md#gpt-4o-prompt-refinement)并支持更多语言。

## 视频压缩网络

在Open-Sora 1.2中，视频压缩架构采用了模块化方法，分别处理空间和时间维度。基于Stability AI的SDXL VAE的空间VAE压缩单个帧的空间维度。时间VAE则处理来自空间VAE的潜在表示以实现时间压缩。这种两阶段设计实现了有效的空间和时间压缩，但也带来了一些限制。这些限制包括由于固定长度输入帧而导致的长视频处理效率低下、空间和时间特征之间缺乏无缝集成，以及在训练和推理过程中更高的内存需求。

Open-Sora 1.3引入了统一的视频压缩方法。通过将空间和时间处理结合到单一框架中，并利用诸如分块3D卷积和动态帧支持等高级特性，Open-Sora 1.3实现了更好的效率、可扩展性和重建质量。以下是Open-Sora 1.3 VAE的主要改进：

**1. 统一的时空处理：** 不同于使用独立的VAE进行空间和时间压缩，Open-Sora 1.3采用单一的编码器-解码器结构同时处理这两个维度。这种方法消除了中间表示和空间-时间模块之间的冗余数据传输的需求。

**2. 分块3D卷积：** Open-Sora 1.3在时间维度上引入了分块3D卷积支持。通过将视频分解成更小的时间块，该特性实现了对更长视频序列的高效编码和解码，而不会增加内存开销。这一改进解决了Open-Sora 1.2在处理大量帧时的限制，确保了更高的时间压缩灵活性。

**3. 动态微批次和微帧处理：** Open-Sora 1.3引入了新的微批次和微帧处理机制。这实现了：(1) 自适应时间重叠：时间编码和解码过程中的重叠帧帮助减少块边界的不连续性。(2) 动态帧大小支持：不再局限于固定长度序列（如Open-Sora 1.2中的17帧），Open-Sora 1.3支持动态序列长度，使其能够适应不同的视频长度。

**4. 统一的归一化机制：** Open-Sora 1.3中的归一化过程通过可调的缩放(scale)和平移(shift)参数得到了改进，确保了不同数据集间潜在空间分布的一致性。与Open-Sora 1.2特定于固定数据集的归一化不同，这个版本引入了更通用的参数并支持特定于帧的归一化策略。

#### 改进总结

| 特性           | Open-Sora 1.2                    | Open-Sora 1.3                     |
|---------------|---------------------------------|----------------------------------|
| **架构**       | 独立的空间和时间VAE                 | 统一的时空VAE                      |
| **分块处理**    | 不支持                           | 支持（分块3D卷积）                   |
| **帧长度支持**  | 固定（17帧）                      | 支持动态帧长度和重叠                 |
| **归一化**     | 固定参数                         | 可调的缩放和平移参数                 |

## 包含滑动窗口注意力的STDiT

在Open-Sora 1.2取得成功的基础上，1.3版本引入了多项架构改进和新功能，以提升视频生成的质量和灵活性。本节概述了这两个版本之间的主要改进和差异。

最新的扩散模型（如Stable Diffusion 3）采用[rectified flow](https://github.com/gnobitab/RectifiedFlow)代替DDPM以获得更好的性能。虽然SD3的rectified flow训练代码未开源，但OpenSora按照SD3论文提供了训练代码实现。OpenSora 1.2从SD3引入了几个关键策略：

1. 基础的rectified flow训练，实现连续时间扩散
2. Logit-norm采样用于加速训练（遵循SD3论文第3.1节），优先在中等噪声水平采样时间步
3. 分辨率和视频长度感知的时间步采样（遵循SD3论文第5.3.2节），对更大分辨率和更长视频使用更多噪声

在OpenSora 1.3中，我们在架构、功能和性能方面进行了显著改进：

#### 1. 位移窗口注意力机制
- 引入可配置kernel_size的基于核的局部注意力，提高计算效率
- 实现类似Swin Transformer的位移窗口分区策略
- 增加带extra_pad_on_dims支持的窗口边界填充掩码处理
- 在局部窗口（时间、高度、宽度）内扩展3D相对位置编码

#### 2. 增强的位置编码
- 改进RoPE实现，将rotation_dim降至原来的1/3以适应3D场景
- 为时间、高度和宽度维度添加独立的旋转嵌入
- 实现分辨率自适应的位置编码缩放
- 可选的空间RoPE以更好地建模空间关系

#### 3. 灵活的生成能力
- 添加I2V和V2V功能，配备专门的条件控制机制
- 引入条件嵌入模块（x_embedder_cond和x_embedder_cond_mask）
- 零初始化条件嵌入以实现稳定训练
- 通过skip_temporal选项实现灵活的时序建模

#### 4. 性能优化
- 改进Flash Attention触发条件（N > 128）以提高效率
- 添加torch.scaled_dot_product_attention (SDPA)作为替代后端
- 通过改进的填充和窗口分区优化内存使用
- 通过自适应高度填充增强序列并行性

从[PixArt-Σ 2K](https://github.com/PixArt-alpha/PixArt-sigma)的适应过程保持相似，但增加了额外步骤：
[第1-7点与v1.2相同：多分辨率训练、QK-norm、rectified flow、logit-norm采样、更小的AdamW epsilon、新VAE和基础时序注意力]
#### 8. 增强的时序模块
   - 添加带位移窗口支持的基于核的局部注意力
   - 实现带分辨率自适应缩放的3D相对位置编码
   - 采用改进的初始化策略进行投影层零初始化

相比专注于基础视频生成的v1.2，v1.3在三个关键领域带来了实质性改进：**1. 质量**：通过位移窗口注意力和3D位置编码增强时空建模。**2. 灵活性**：支持I2V/V2V任务和可配置的时序建模。**3. 效率**：优化注意力计算和内存使用

这些改进在保持v1.2核心功能的同时，扩展了模型在实际应用中的能力。模型保留了使用rectified flow生成高质量图像和视频的能力，同时在条件生成和长序列建模方面获得了新的优势。

## 简单有效的模型条件控制

我们对每个视频片段计算美学分数和运动分数，并过滤掉得分较低的片段，从而得到一个视频质量更好的数据集。此外，我们将这些分数附加到标题中并用作条件控制。具体来说，我们基于预定义的范围将数值分数转换为描述性语言。美学分数转换函数基于预定义范围将数值美学分数转换为描述标签：低于4分标记为"terrible"，依次通过"very poor"、"poor"、"fair"、"good"和"very good"，6.5分或更高标记为"excellent"。同样，运动分数转换函数将运动强度分数映射为描述符：低于0.5分标记为"very low"，依次通过"low"、"fair"、"high"和"very high"，20分或更高标记为"extremely high"。我们发现这种方法可以使模型意识到这些分数并遵循分数来生成更高质量的视频。

例如，对于一个美学分数为5.5，运动分数为10，检测到的相机运动为向左平移的视频，其标题将是：

```plaintext
[Original Caption] The aesthetic score is good, the motion strength is high, camera motion: pan left.
```

在推理过程中，我们也可以使用这些分数来控制模型。对于相机运动，我们只标记了13k个高置信度的片段，相机运动检测模块已在我们的工具中发布。

## 评估方法

此前，我们仅通过人工评估来监控训练过程，因为DDPM训练损失与生成视频的质量相关性不高。然而，对于rectified flow，我们发现正如SD3所述，训练损失与生成视频的质量有很好的相关性。因此，我们持续跟踪100张图像和1k个视频的rectified flow评估损失。

我们从pixabay采样了1k个视频作为验证数据集。我们计算了不同分辨率（360p，720p）下图像和不同长度视频（49帧、65帧、81帧、97帧、113帧）的评估损失。对于每种设置，我们等距采样10个时间步。然后对所有损失取平均值。

此外，我们还在训练期间跟踪[VBench](https://vchitect.github.io/VBench-project/)分数。VBench是一个用于短视频生成的自动视频评估基准。我们使用360p 49帧视频计算vbench分数。这两个指标验证了我们的模型在训练过程中持续改进。

所有评估代码都在`eval`文件夹中发布。查看[README](/eval/README.md)获取更多详细信息。